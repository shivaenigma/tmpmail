#!/usr/bin/env bash
source ./config.txt
[ -z "$APIKEY" ] && echo "Missing API Key. Please specify APIKey in config.txt" && exit
	
#
# by Siddharth Dushantha 2020
#
# Dependencies: jq, curl, w3m
#

version=1.2.3

# By default 'tmpmail' uses 'w3m' as it's web browser to render
# the HTML of the email
browser="w3m"

# If the value is set to 'true' tmpmail will convert the HTML email
# to raw text and send that to stdout
raw_text=false

# Everything related to 'tmpmail' will be stored in /tmp/tmpmail
# so that the old emails and email addresses get cleared after
# restarting the computer
tmpmail_dir="/tmp/tmpmail"

# The default command that will be used to copy the activation code to
# the user's clipboard 
copy_to_clipboard_cmd="xclip -selection c"


# tmpmail.html is where the email gets stored.
# Even though the file ends with a .html extension, the raw text version of
# the email will also be stored in this file so that w3m and other browsers
# are able to open this file
tmpmail_html_email="$tmpmail_dir/tmpmail.html"


# Default 1secmail API URL
tmpmail_api_url="https://emptyinbox.me/api"

usage() {
    # Using 'cat << EOF' we can easily output a multiline text. This is much
    # better than using 'echo' for each line or using '\n' to create a new line.
    cat <<EOF
tmpmail
tmpmail -h | --version
tmpmail -g 
tmpmail -l
tmpmail [--clipboard-cmd COMMAND] -a
tmpmail [-t | -b BROWSER] -r | ID

When called with no option and no argument, tmpmail lists the messages in
the inbox and their numeric IDs.  When called with one argument, tmpmail
shows the email message with specified ID.

-b, --browser BROWSER
        Specify BROWSER that is used to render the HTML of
        the email (default: w3m)
    --clipboard-cmd COMMAND
        Specify the COMMAND to use for copying the activation code to your
        clipboard (default: xclip -selection c)
-l, --list
        Show list of available inboxes
-g, --generate 
        Generate a new email inbox        
-a, --acode
        Auto Detect and dump activation code from recent email  
-h, --help
        Show help
-r, --recent
        View the most recent email message
-t, --text
        View the email as raw text, where all the HTML tags are removed.
        Without this option, HTML is used.
--version
        Show version
EOF
}


list_inboxes() {
    data=$(call_api inboxes)
    out=$(printf "%s" "$data" | jq -r '.[].inbox')
    echo "$out"
}

generate_inbox() {
    data=$(curl -d'{}' -sL "$tmpmail_api_url/inbox" -H "Authorization:Bearer $APIKEY")
    echo $data
}

trap "exit 1" TERM
TOP_PID=$$


call_api() {
    # Fetch the email data using inboxme API and exit script if got abnormal http code
    response=$(curl -w "\n%{http_code}" -sL "$tmpmail_api_url/$1" -H "Authorization:Bearer $APIKEY")
    http_code=$(tail -n1 <<< "$response")  # get the last line
    data=$(sed '$ d' <<< "$response")   # get all but the last line which contains the status code

    if [ "$http_code" -gt 400 ]; then
	    echo "$data" 1>&2
	    kill -s TERM $TOP_PID
    fi 	    
    echo $data
}

list_emails() {
    # List all the received emails in a nicely formatted order
    #
    data=$(call_api messages) 

    # Using 'jq' we get the length of the JSON data. From this we can determine whether or not
    # the email address has gotten any emails
    data_length=$(printf %s "$data" | jq length)

    # If the length of the data we got is 0, that means the email address
    # has not received any emails yet.
    [ "$data_length" -eq 0 ] && echo "No new mail" && exit

    # This is where we store all of our emails, which is then
    # displayed using 'column'
    inbox=""

    # Go through each mail that has been received
    index=1
    while [ $index -le "${data_length}" ]; do
        # Since arrays in JSON data start at 0, we must subtract
        # the value of $index by 1 so that we dont miss one of the
        # emails in the array
        mail_data=$(printf %s "$data" | jq -r ".[$index-1]")
        id=$(printf %s "$mail_data" | jq -r ".id")
        to=$(printf %s "$mail_data" | jq -r ".inbox")
        subject=$(printf %s "$mail_data" | jq -r ".subject")

        # The '||' are used as a divideder for 'column'. 'column' will use this divider as
        # a point of reference to create the division. By default 'column' uses a blank space
        # but that would not work in our case as the email subject could have multiple white spaces
        # and 'column' would split the words that are seperated by white space, in different columns.
        inbox="$inbox$id ||$to ||$subject\n"
        index=$((index + 1))
    done

    # Show the emails cleanly
    printf "%b" "$inbox" | column -t -s "||"
}


view_email() {
    # View an email by providing it's ID
    #
    # The first argument provided to this function will be the ID of the email
    # that has been received
    inbox_id="$1"
    data=$(call_api message/$inbox_id)

    # After the data is retrieved using the API, we have to check if we got any emails.
    # Luckily 1secmail's API is not complicated and returns 'Message not found' as plain text
    # if our email address as not received any emails.
    # If we received the error message from the API just quit because there is nothing to do
    [ "$data" = "Message not found" ] && die "Message not found"

    # We pass the $data to 'jq' which extracts the values
    from=$(printf %s "$data" | jq -r ".sender")
    to=$(printf %s "$data" | jq -r ".headers.To")
    subject=$(printf %s "$data" | jq -r ".headers.Subject")
    html_body=$(printf %s "$data" | jq -r ".html_body")
    text_body=$(printf %s "$data" | jq  -r ".text_body")
    attachments=$(printf %s "$data" | jq -r ".attachments | length")
    # If you get an email that is in pure text, the .htmlBody field will be empty and
    # we will need to get the content from .textBody instead
    [ "$html_body" = "null" ] && html_body="<pre>$(printf %s "$data" | jq -r ".text_body")</pre>"

    # Create the HTML with all the information that is relevant and then
    # assigning that HTML to the variable html_mail. This is the best method
    # to create a multiline variable
    html_mail=$(cat <<EOF
<pre><b>To: </b>$to
<b>From: </b>$from
<b>Subject: </b>$subject</pre>
$html_body

EOF
)


    # Save the $html_mail into $tmpmail_html_email
    printf %s "$html_mail" >"$tmpmail_html_email"

    # If the '--text' flag is used, then use 'w3m' to convert the HTML of
    # the email to pure text by removing all the HTML tags
    if [ "$raw_text" = true ]; then
	    if [ "$text_body" = "null" ]; then
		    w3m -dump $tmpmail_html_email
	    else
		    text_mail="To: $to\nFrom: $from\nSubject: $subject\n$text_body"
		    echo "$text_mail"
	    fi
	    exit
    fi

    # Open up the HTML file using $browser. By default,
    # this will be 'w3m'.
    $browser "$tmpmail_html_email"
}


view_recent_email() {
    # View the most recent email.
    #
    # This is done by listing all the received email like you
    # normally see on the terminal when running 'tmpmail'.
    # We then grab the ID of the most recent
    # email, which the first line.
    inbox_id=$(list_emails | head -1 | cut -d' ' -f 1)
    echo $inbox_id
    view_email "$inbox_id"
}

activation_code(){
    #Use regex to detect activation code from email
    #Skip 4 lines from recent email to get msg boxy
    raw_text=true
    text=$(view_recent_email | tail -n +5)
    if [[ "$text" =~ ([A-Z,0-9]{4,}) ]]; then
	    code=${BASH_REMATCH[1]}
	    echo "$code" | $copy_to_clipboard_cmd 
	    echo "Activation code $code copied to clipboard"
    else
	    echo "Could not detect activation code"
    fi 
}


die() {
    # Print error message and exit
    #
    # The first argument provided to this function will be the error message.
    # Script will exit after printing the error message.
    printf "%b\n" "Error: $1" >&2
    exit 1
}

main() {
    # Iterate of the array of dependencies and check if the user has them installed.
    # We are checking if $browser is installed instead of checking for 'w3m'. By doing
    # this, it allows the user to not have to install 'w3m' if they are using another
    # browser to view the HTML.
    #
    # dep_missing allows us to keep track of how many dependencies the user is missing
    # and then print out the missing dependencies once the checking is done.
    dep_missing=""

    # The main command from $copy_to_clipboard_cmd
    # Example:
    #   xclip -selection c
    #   ├───┘
    #   └ This part
    clipboard=${copy_to_clipboard_cmd%% *}

    for dependency in jq $browser $clipboard curl; do
        if ! command -v "$dependency" >/dev/null 2>&1; then
            # Append to our list of missing dependencies
            dep_missing="$dep_missing $dependency"
        fi
    done

    if [ "${#dep_missing}" -gt 0 ]; then
        printf %s "Could not find the following dependencies:$dep_missing"
        exit 1
    fi


    # If no arguments are provided just the emails
    [ $# -eq 0 ] && list_emails && exit

    while [ "$1" ]; do
        case "$1" in
            --help | -h) usage && exit ;;
            --list | -l) list_inboxes && exit ;;
            --generate | -g) generate_inbox  && exit ;;
	    --clipboard-cmd) copy_to_clipboard_cmd="$2" ;;
            --acode | -a) activation_code  && exit ;;
            --browser | -b) browser="$2" ;;
            --text | -t) raw_text=true ;;
            --version) echo "$version" && exit ;;
            --recent | -r) view_recent_email && exit ;;
            *[0-9]*)
                # If the user provides number as an argument,
                # assume its the ID of an email and try getting
                # the email that belongs to the ID
                view_email "$1" && exit
                ;;
            -*) die "option '$1' does not exist" ;;
        esac
        shift
    done
}

main "$@"
